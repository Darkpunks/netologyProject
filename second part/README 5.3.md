__________________________________________________________________________
Домашнее задание к занятию "5.3. Введение. Экосистема. Архитектура. Жизненный цикл Docker контейнера"
__________________________________________________________________________

Задача 1
__________________________________________________________________________
Сценарий выполения задачи:

создайте свой репозиторий на https://hub.docker.com;
выберете любой образ, который содержит веб-сервер Nginx;
создайте свой fork образа;
реализуйте функциональность: запуск веб-сервера в фоне с индекс-страницей, содержащей HTML-код ниже:
```
<html>
<head>
Hey, Netology
</head>
<body>
<h1>I’m DevOps Engineer!</h1>
</body>
</html>
Опубликуйте созданный форк в своем репозитории и предоставьте ответ в виде ссылки на https://hub.docker.com/username_repo.
```

ОТВЕТ:  https://hub.docker.com/r/darkpunks/apache2-netology/


__________________________________________________________________________
Задача 2
__________________________________________________________________________

Посмотрите на сценарий ниже и ответьте на вопрос: "Подходит ли в этом сценарии использование Docker контейнеров или лучше подойдет виртуальная машина, физическая машина? Может быть возможны разные варианты?"

Детально опишите и обоснуйте свой выбор.

--

Сценарий:

0.Высоконагруженное монолитное java веб-приложение;
1.Nodejs веб-приложение;
2.Мобильное приложение c версиями для Android и iOS;
3.Шина данных на базе Apache Kafka;
4.Elasticsearch кластер для реализации логирования продуктивного веб-приложения - три ноды elasticsearch, два logstash и две ноды kibana;
5.Мониторинг-стек на базе Prometheus и Grafana;
6.MongoDB, как основное хранилище данных для java-приложения;
7.Gitlab сервер для реализации CI/CD процессов и приватный (закрытый) Docker Registry.

ОТВЕТ:
0.Высоконагруженное монолитное java веб-приложение - так как будет высокая нагрузка, лучше всего размещать на физической среде для быстродействия системы, а  монолитное веб-приложение подразумевает что всё будет происходить в одном месте. 

1.Nodejs веб-приложение - Контейнеризация. Так как Node.js добавляет возможность JavaScript взаимодействовать с устройствами ввода-вывода через свой API, написанный на C++, подключать другие внешние библиотеки, написанные на разных языках, обеспечивая вызовы к ним из JavaScript-кода. Ему необходима Масштабируемость, Ускорение и автоматизация развертывания приложений и Контейнеры приближают к микросервисной архитектуре.


2.Мобильное приложение c версиями для Android и iOS - моно попробовать контейнирезацию. Контейнер не хранит никаких изменений, и каждая сборка запускается с нуля, что с одной стороны гарантирует идентичность сборки независимо от места ее запуска, с другой стороны каждый раз приходиться скачивать все зависимости и компилировать весь код заново, а это иногда может занимать существенное время. Но, всё это, само собой, имеет смысл только если у вас есть собственный внутренний CI/CD сервер, поддержкой которым необходимо заниматься. Но сейчас есть много облачных сервисов в которых все эти проблемы решены и вам не надо об этом переживать и нужные свойства сборки можно так же указать в настройках проекта.

3.Шина данных на базе Apache Kafka - контейнеризация. Сама по себе Apache Kafka - это распределенная потоковая платформа. В данном случае предоставляется шина с колоссальной пропускной способностью, на которой можно в реальном времени обрабатывать абсолютно все проходящие через нее данные.  Особенность шины кафка в том, что она позволяет на ранних этапах заложить в архитектуру бэкенда структуры, которые можно беспроблемно масштабировать в будущем.

4.Elasticsearch кластер для реализации логирования продуктивного веб-приложения - три ноды elasticsearch, два logstash и две ноды kibana - Контейнеризация. Например, 2ГИС используют стэк технологий Elasticsearch + Logstash + Kibana, сокращённо ELK. Elasticsearch — NoSQL-хранилище документов, с возможностью полнотекстового поиска. Logstash настроен на приём логов по TCP/UDP-протоколам, читает сообщения из Redis и сохраняет в Elasticsearch. Kibana предоставляет визуальный интерфейс для поиска и отображения собранных данных.


5.Мониторинг-стек на базе Prometheus и Grafana.  Физическое/виртуализация. Например, с сервера Prometheus может быть текущее использование свободной памяти или файловой системы через Node Exporter на сервере Prometheus, а Grafana можно использовать в качестве стороннего компонента для визуализации метрик, хранящихся в базе данных временных рядов Prometheus. Вместо того чтобы писать запросы PromQL непосредственно на сервер Prometheus, использовавть доски графического интерфейса Grafana для запроса метрик с сервера Prometheus и визуализации их на панели мониторинга Grafana.

6.MongoDB, как основное хранилище данных для java-приложения - Виртуализаци. Сам MongoDB  спроектирован для горизонтального масштабирования, и являются устойчивыми к падению виртуальных машин. Ресурсы могут быть расширены за счет добавления новых экземпляров приложений на однотипных виртуальных серверах с последующей балансировкой нагрузки. Эти распределенные приложения самостоятельно обеспечивают собственную отказоустойчивость на уровне приложения, независимо от базовой инфраструктуры и передовых функций гипервизоров.

7.Gitlab сервер для реализации CI/CD процессов и приватный (закрытый) Docker Registry - Контейнеризация. Многие команды, использующие CI/CD-конвейеры в облаках используют контейнеры, такие как Docker, и системы оркестрации. Контейнеры позволяют стандартизировать упаковку, поставку и упростить масштабирование и уничтожение окружений с непостоянной нагрузкой. Архитектура бессерверных вычислений представляет собой еще один способ развертывания и масштабирования приложений. В бессерверном окружении инфраструктурой полностью управляет поставщик облачных услуг, а приложение потребляет ресурсы по мере необходимости в соответствии с его настройками. 


__________________________________________________________________________
Задача 3
__________________________________________________________________________
Запустите первый контейнер из образа centos c любым тэгом в фоновом режиме, подключив папку /data из текущей рабочей директории на хостовой машине в /data контейнера;
Запустите второй контейнер из образа debian в фоновом режиме, подключив папку /data из текущей рабочей директории на хостовой машине в /data контейнера;
Подключитесь к первому контейнеру с помощью docker exec и создайте текстовый файл любого содержания в /data;
Добавьте еще один файл в папку /data на хостовой машине;
Подключитесь во второй контейнер и отобразите листинг и содержание файлов в /data контейнера.


ОТВЕТ:
```
mkdir data

docker run -dt -v $PWD/data:/data --name centos centos:latest

docker run -dt -v $PWD/data:/data --name debian debian:latest

docker exec -ti centos bash

touch /data/centos

exit

touch data/host

docker exec -ti debian bash

ls /data

exit
```

<img width="700" alt="2" src="https://github.com/Darkpunks/netologyProject/blob/main/second%20part/5.3/5.3.2.jpg">


<img width="700" alt="2" src="https://github.com/Darkpunks/netologyProject/blob/main/second%20part/5.3/5.3.1.jpg">

